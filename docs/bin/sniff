#! /usr/bin/env php

<?php

use Symfony\Component\Console\Output\ConsoleOutput;

$skipDots = FilesystemIterator::SKIP_DOTS;
$keyAsFilename = FilesystemIterator::KEY_AS_FILENAME;
$modules = new FilesystemIterator(__DIR__ . '/../../src/Codeception/Module', $skipDots | $keyAsFilename);

require_once __DIR__ . '/../../vendor/autoload.php';

$missingExample = [];
$voidReturn = [];
$paramPattern = '/@param\\s+(?<types>[^\\s]+)\\s+(?<name>\\$[^\\s]+)\\s+(?<comment>[^\\s]+)/u';
$returnPattern = '/@return\\s+(?<type>[^\\s]+)\\s+(?<comment>[^\\s]+)/u';
$missingParamComment = [];
$missingReturnComment = [];

/** @var \SplFileInfo $fileInfo */
foreach ($modules as $module => $fileInfo) {
    $moduleName = basename($module, '.php');
    $class = 'Codeception\\Module\\' . $moduleName;
    $reflectionClass = new ReflectionClass($class);
    $methods = $reflectionClass->getMethods(ReflectionMethod::IS_PUBLIC);
    $methods = array_filter($methods, static function (ReflectionMethod $method) use ($class) {
        return strpos($method->name, '_') !== 0
               && $method->getDeclaringClass()->name === $class
               && strpos($method->getDocComment(), '@internal') === false;
    });
    /** @var \ReflectionMethod $method */
    foreach ($methods as $method) {
        $docBlock = $method->getDocComment();
        if (strpos($docBlock, ' @example') === false) {
            $missingExample["{$moduleName}::{$method->name}"] = "{$fileInfo->getPath()}:{$method->getStartLine()}";
        }
        if (strpos($docBlock, ' @return void') !== false) {
            $voidReturn["{$moduleName}::{$method->name}"] = "{$fileInfo->getPath()}:{$method->getStartLine()}";
        }

        $lines = explode(PHP_EOL, $docBlock);

        foreach ($lines as $line) {
            if (strpos($line, "@param") !== false) {
                if (!preg_match($paramPattern, $line)) {
                    $missingParamComment["{$moduleName}::{$method->name}"] = "{$fileInfo->getPath()}:{$method->getStartLine()}";
                }

                continue;
            }

            if (strpos($line, "@return") !== false) {
                if (!preg_match($returnPattern, $line)) {
                    $missingReturnComment["{$moduleName}::{$method->name}"] = "{$fileInfo->getPath()}:{$method->getStartLine()}";
                }
            }
        }
    }
}

$output = new ConsoleOutput();

if (empty($missingExample) && empty($voidReturn) && empty($missingParamComment) && empty($missingReturnComment)) {
    $output->writeln('<info>Everything is fine with the modules documentation blocks.</info>');
    echo PHP_EOL;
    exit(0);
}

if (!empty($missingExample)) {
    $output->writeln("<error>Some methods are missing an @example entry, here's a list.</error>");
    $output->writeln('<info>(Paths will be clickable in any modern shell to edit them directly.)</info>');
    echo PHP_EOL;
    foreach ($missingExample as $moduleMethod => $path) {
        $output->writeln("<comment>{$moduleMethod} => </comment> {$path}");
    }
    echo PHP_EOL;
}

if (!empty($voidReturn)) {
    $output->writeln("<error>Some methods have a '@return void' entry, here's a list.</error>");
    $output->writeln('<info>(Paths will be clickable in any modern shell to edit them directly.)</info>');
    echo PHP_EOL;
    foreach ($voidReturn as $moduleMethod => $path) {
        $output->writeln("<comment>{$moduleMethod} => </comment> {$path}");
    }
    echo PHP_EOL;
}

if (!empty($missingParamComment)) {
    $output->writeln("<error>Some methods have a '@param' entry missing a comment, here's a list.</error>");
    $output->writeln('<info>(Paths will be clickable in any modern shell to edit them directly.)</info>');
    echo PHP_EOL;
    foreach ($missingParamComment as $moduleMethod => $path) {
        $output->writeln("<comment>{$moduleMethod} => </comment> {$path}");
    }
    echo PHP_EOL;
}

if (!empty($missingReturnComment)) {
    $output->writeln("<error>Some methods have a '@return' entry missing a comment, here's a list.</error>");
    $output->writeln('<info>(Paths will be clickable in any modern shell to edit them directly.)</info>');
    echo PHP_EOL;
    foreach ($missingReturnComment as $moduleMethod => $path) {
        $output->writeln("<comment>{$moduleMethod} => </comment> {$path}");
    }
    echo PHP_EOL;
}

exit(1);


